from collections import namedtuple

"""A wrapper passed internally by the bus."""
MessageEnvelope = namedtuple("MessageEnvelope", ["body"])

"""A container for details about a message + failed handler"""
InvocationFailure = namedtuple("InvocationFailure", ["message", "exception", "stack_trace", "invocation_context"])

<<<<<<< HEAD
class BusState(object):
    """A thread local state object."""
    def __init__(self):
        self.session = Session()
        self.current_message = None
        self._deferred = []
=======
class Headers(object):
    ID = "id"
    CREATED = "created"
    PROCESS = "process"
    HOST = "host"
    REPLY_TO = "reply-to"
    CORRELATION_ID = "correlation-id"
    
class ContextKeys(object):
    REPLY_SEND_KWARGS = "_reply_send_kwargs"

class BaseContext(object):
    def __init__(self, headers=None):
        self._headers = defaultdict(list)
        self.add_header(Headers.ID, str(uuid.uuid4()))
        self.add_header(Headers.CREATED, time.time())
        self.add_header(Headers.PROCESS, os.getpid())
        self.add_header(Headers.HOST, os.uname()[1])
        
        for h in headers or {}:
            vals = headers[h]
            if isinstance(vals, (list, tuple)):               
                self._extend_header(h, vals)
            else:
                self.add_header(h, vals)
        
    def __repr__(self):
        return "%r" % dict(self._headers)
    
    def __str__(self):
        return str(unicode(self).encode('utf8'))
        
    def __unicode__(self):
        a = []
        for h, vals in self._headers.iteritems():
            for v in vals:
                a.append(u"%s: %s" % (h, v))
        return u"\n".join(a)
    
    def __contains__(self, key):
        key = key.lower()
        return key in self._headers
            
    def add_header(self, key, value):
        """Adds a header; multiple headers of the same type can be added."""
        if type(value) not in (str, unicode, int, float, bool, types.NoneType):
            raise ValueError("Only scalar types are allowed as headers (%s)" % type(value))
        self._headers[key.lower()].append(value)
        
    def _extend_header(self, key, values):
        for _v in values:
            self.add_header(key, _v)
        
    @property
    def all_headers(self):
        return self._headers

    def headers(self, key):
        key = key.lower()
        if key not in self._headers:
            return []
        return self._headers[key]
    
    def header(self, key):
        key = key.lower()
        if key in self._headers:
            return self._headers[key][-1]
        return None
    
    

class SessionContext(BaseContext):
    def copy(self):
        return self.__class__(self._headers)


class RequestContext(BaseContext):
    def __init__(self, headers=None, parent=None, inherit_session=True):
        super(RequestContext, self).__init__(headers)
        self.session = None
>>>>>>> Interim checkpoint; failing to handle the requests scope.
        self._queued_messages = []

    def consume_messages(self):
        """A destructive iterator for consuming all queued messages."""
        while self._queued_messages:
            yield self._queued_messages.pop()
        
    def is_queue_empty(self):
        """Got messages?"""
        return len(self._queued_messages) == 0
        
    def enqueue(self, message):
        """Enqueue a message during this session."""
        self._queued_messages.append(message)


class Session(dict):
    """A bag for storing session variables during a Bus.send() call."""
    def __init__(self, **kwargs):
        self.update(kwargs)
                
